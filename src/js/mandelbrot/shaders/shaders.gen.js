// GENERATED FILE (gulp-js-inline-resource)
goog.provide('mandelbrot.shaders');
/** @type {Object.<string,string>} */
mandelbrot.shaders = {
  "viewport.vert.glsl": "#define GLSLIFY 1\n// precision highp float;\n\nattribute vec2 vertex;\n\nvoid main() {\n  gl_Position = vec4(vertex, 0, 1);\n}\n",
  "copy.frag.glsl": "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 size;\n\nuniform sampler2D field;\n\nuniform vec2 offset;\n\nvec4 texel(sampler2D tex, vec2 size, vec2 px) {\n  // Flip y-axis.\n  px.y = size.y - 1.0 - px.y;\n  \n  vec2 pos = (2.0 * px + 1.0) / (2.0 * size);\n\n  return texture2D(tex, pos);\n}\n\nvoid main() {\n  vec2 px = gl_FragCoord.xy - 0.5;\n  px.y = size.y - 1.0 - px.y;\n\n  px += offset;\n\n  if (px.x < 0.0 || px.x >= size.x || px.y < 0.0 || px.y >= size.y) {\n    gl_FragColor = vec4(0,0,0,0);\n  } else {\n    gl_FragColor = texel(field, size, px);\n  }\n}\n",
  "draw.frag.glsl": "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nuniform vec2 size;\nuniform sampler2D field;\nuniform int iterations;\nuniform int visualization;\nuniform int logarithmic;\nuniform int periodic;\nuniform int period;\nuniform float phase;\nuniform int periodAnchor;\nuniform int smooth;\n\nvec4 texel(sampler2D tex, vec2 size, vec2 px) {\n  // Flip y-axis.\n  px.y = size.y - 1.0 - px.y;\n  \n  vec2 pos = (2.0 * px + 1.0) / (2.0 * size);\n\n  return texture2D(tex, pos);\n}\n\nint PERIOD_ANCHOR_FRONT = 1;\n\n// Single precision floating point number use 23 bits for the fraction.\n// 2^(23-1) = 4194304\nfloat INT_PACK_FACTOR = 4194304.0;\n\nint BLACK_AND_WHITE = 1;\nint GREY_SCALE = 2;\n\nvoid main() {\n  vec2 px = gl_FragCoord.xy - 0.5;\n  px.y = size.y - px.y - 1.0;\n\n  vec4 tx = texel(field, size, px);\n  float real = tx[0];\n  float img = tx[1];\n  float n = tx[2] * INT_PACK_FACTOR;\n  float diverging = tx[3];\n\n  if (visualization == BLACK_AND_WHITE) {\n    if (diverging == 0.0) {\n      gl_FragColor = vec4(0, 0, 0, 1);\n    } else {\n      gl_FragColor = vec4(1, 1, 1, 1);\n    }\n\n  } else if (visualization == GREY_SCALE) {\n    if (diverging == 0.0) {\n      gl_FragColor = vec4(0, 0, 0, 1);\n    } else {\n      float max = float(iterations);\n\n      if (periodic == 1) {\n        if (periodAnchor == PERIOD_ANCHOR_FRONT) {\n          n += float(period) - mod(float(iterations), float(period));\n        }\n        // Apply phase.\n        n += phase * float(period);\n        // Modulo.\n        n = mod(n, float(period));\n        max = float(period) - 1.0;\n\n        if (smooth == 1) {\n          n = n * 2.0;\n          if (n > max) {\n            n = max - (n - max);\n          }\n        }\n        if (logarithmic == 1) {\n          n += 1.0;\n          max += 1.0;\n        }\n      }\n\n      float v;\n      if (logarithmic == 1) {\n        v = log2(n) / log2(max);\n      } else {\n        v = n / max;\n      }\n      gl_FragColor = vec4(v, v, v, 1);\n    }\n  }\n}\n  ",
  "iter.frag.glsl": "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nuniform vec2 size;\nuniform vec2 tl;\nuniform float delta;\nuniform int iterationsPerUpdate;\nuniform int targetIterations;\nuniform int catchUpSpeedUp;\nuniform sampler2D field;\n\nvec4 texel(sampler2D tex, vec2 size, vec2 px) {\n  // Flip y-axis.\n  px.y = size.y - 1.0 - px.y;\n  \n  vec2 pos = (2.0 * px + 1.0) / (2.0 * size);\n\n  return texture2D(tex, pos);\n}\n\n// Single precision floating point number use 23 bits for the fraction.\n// 2^(23-1) = 4194304\nfloat INT_PACK_FACTOR = 4194304.0;\n\nvoid main() {\n  vec2 px = gl_FragCoord.xy - 0.5;\n  px.y = size.y - px.y - 1.0;\n\n  vec4 tx = texel(field, size, px);\n  float diverging = tx[3];\n\n  if (diverging > 0.0) {\n    gl_FragColor = tx;\n    return;\n  }\n\n  vec2 c = tl + vec2(px.x, -px.y) * delta;\n  float cr = c[0];\n  float ci = c[1];\n\n  float zr = tx[0];\n  float zi = tx[1];\n  float n = tx[2] * INT_PACK_FACTOR;\n\n  float r;\n  float i;\n  // NOTE: Cannot use uniform n in a loop condition:\n  // \"Loop index cannot be compared with non-constant expression.\"\n\n  int numIter = iterationsPerUpdate;\n  if (int(n) + iterationsPerUpdate < targetIterations) {\n    numIter *= catchUpSpeedUp;\n  }\n\n  for (int idx = 0; idx < 100; idx++) {\n    if (idx == numIter) break;\n\n    r = zr * zr - zi * zi + cr;\n    i = zr * zi + zi * zr + ci;\n    zr = r;\n    zi = i;\n    n += 1.0;\n\n    if (r * r + i * i > 4.0) {\n      diverging = 1.0;\n      break;\n    }\n  }\n\n  gl_FragColor = vec4(r, i, n / INT_PACK_FACTOR, diverging);\n}\n\n"
};
